Exercise 0 - obtaining Vampire:
-------------------------------

The source code of Vampire is available at 

https://github.com/vprover/vampire

for evaluation and research purposes (see LICENCE there for more details).

Full official vampire, that we will be using, requires the SMT solver Z3 as a library.

Z3 has been pre-installed on the provided VM. 

(In general, make sure there is sub-directory "include" of your "vampire" directory
and that it contains (a link to) the z3 library file "libz3.so" (unix) / "libz3.dylib" (mac).
In might be necessary to also make LD_LIBRARY_PATH (unix) / DYLD_LIBRARY_PATH (mac) contain the path
the this vampire's "include" dir.)

--- on the provided VM ---

- start the Terminal
- cd vampire
- git pull
- make vampire_z3_rel -j 3

should give us (as of 5 July 2018) vampire_z3_rel_master_3993


Exercise 1 - Limited Resource Strategy (LRS) and the time limit
---------------------------------------------------------------

Under certain conditions, LRS may behave in surprising ways. Because it actively discards
clauses which are estimated not to be useful before the allotted time is over, it may
prove things faster when given less time. Try running

./vampire_z3_rel_master_3993 -awr 5:1 -fsr off ../satsmtar2018/GRP140-1.p

Note that:
- LRS is on by default (otherwise "-sa lrs")
- "-awr 5:1 -fsr off" (age weight ration and forward subsumption resolution) are set to non-default to enable the desired effect

Now give Vampire less time (than the default 60s) with the option "-t 30", "-t 15", ... "-t 15d" (for 15 deciseconds = 1.5s)

What is the shortest time under which vampire finds a refutation?


Exercise 2 - A bit of group theory and finite model finding
-----------------------------------------------------------

Let's play a bit with the problem "grp_ord2.p" 

1) just let Vampire prove it and try understanding the proof.

./vampire_z3_rel_master_3993 ../satsmtar2018/grp_ord2.p 

2) Comment out the conjecture and run Vampire again as above.

What is it doing? Will it terminate?

Try adding "--show_active on" to see what clause is currently being activated.

Try adding "--show_new on" to see what clauses are getting generated.

ANSWER: It is saturating a satisfiable set of axioms. In theory, it might not terminate at all. 
Although there are cases of finite saturations. (Complete calculus + finite saturation -> problem shown satisfiable.)
We cannot be sure after finitely many steps. (By the way, here we are running with the default time limit of 60s.)

3) Without the conjecture, the problem is satisfiable, however saturation-based approaches are not very good at detecting it!
Let's try finite model building by adding "-sa fmb" 
(yes, the value "fmb" occurs under "saturation strategy", but as a technology, it has nothing to do with saturation).

What did we get? 

ANSWER: Finite model builder constructed a THE one element group (in which every element is of order 2).

4) Can you add an axiom to make Vampire looking for larger models?

ANSWER: For instance, add 

fof(a,axiom,a!=e).

adding an extra constant "a" to the problem and stating it's not equal to the unit element "e".

5) Can you add axioms to force Vampire look for a group (in which every element is of order 2) of size exactly three?

ANSWER:

Add, for instance, 

fof(a,axiom,$distinct(a,b,c)).
fof(a,axiom,![X]:(X = a | X = b | X = c)).

Note that "$distinct(a,b,c)" is a shorthand for "a!=b & b!=c & a!=c".

Note that Vampire starts checking from size 3 as it noticed that 1 and 2 wouldn't work anyway.
Then after trying size 4 realises there cannot be any model and concludes "$false [finite model not found]"

The ability to show problems unsatisfiable using finite model building is a bit fancy. See our paper
"Finding Finite Models in Multi-sorted First-Order Logic. SAT 2016" if interested.

6) Actually, there is no group (in which every element is of order 2) which would have size 3. But it's pretty hard to prove by superposition / saturation.

The default strategy as in

"./vampire_z3_rel_master_3993 ../satsmtar2018/grp_ord2.p"

will have a hard time.

Adding "--mode casc" (instead of "-sa fmb") will employ Vampire's powerful strategy schedule and maybe find a suitable strategy to solve this hard(ish) problem. 

An extra challenge: try understanding the proof!


Exercise 3 - Challenge: Can you find the right strategy?
--------------------------------------------------------

This exercise has been constructed to annoy you! Also to demonstrate 
- how fragile search spaces in first-order logic are. Often we have problems that a certain strategy solves almost instantly, 
while another will not terminate in reasonable time.
- how useful incomplete strategies can be. In the theory talks you have heard that the developers of first-order theorem provers 
like calculi that are complete. Well, if you want to win competitions, take inspiration from Vampire and also employ incomplete ones.
Some our really powerful and help us solve problems which we cannot solve otherwise!

In the slides you have already seen some suggestions on how to obtain interesting strategies different from the default strategy of Vampire. They were obtained by

- turning on the set of support strategy via "-sos on" (this is an incomplete but a very useful strategy!)

- turning off avatar via "-av off" (we solver fewer problems, but there are some which we cannot solve with avatar)

- switching the saturation strategy from the default LRS to discount
  and also adjusting the age weight ratio for this strategy via "-sa discount -awr 10"

- using an incomplete but powerful Lookahead literal selection via "-s 1011"
(see "Selecting the Selection. IJCAR 2016" for more details)
 
- turning on the relatively expensive but often useful reduction called Backward subsumption via "-bs on".

Including the default strategy, this represent 6 distinct strategies for Vampire.

In the folder ./challenge/ you find 6 files (look just at the *.p files, the other ones are axiom files included from the *.p files)
that have been selected such that exactly one of the above strategies succeeds on each of the problems.

Can you find which strategy solves which problem?







CASC





Exercise 4 - Theories in Vampire, theory axioms, SMTLIB input
-------------------------------------------------------------

Giles, please?

--input_syntax smtlib2



Exercise 5 - One new option for theory reasoning
------------------------------------------------

Let have a look at the at an apparently easy problem ./MSC023\=2.p

Giles, please?

-uwa all





- sine ?
- large things?
- cite paper!





Modelling - do a Hilbert calculus thing?




Exercise 5 - Modelling problems in first-order logic and the Question answering mode 
------------------------------------------------------------------------------------

Do you know the puzzle Crossing the River (with a Wolf, a Goat, and a Cabbage)? 
You can check it out, e.g., at http://www.mathcats.com/explore/river/crossing.html

Can you formalise in first-order logic such that whenever Vampire finds a proof
there is a solution to the puzzle? Try it yourself before you proceed!

Possible solution can be found in "./PUZ047variant.p" 
(it was derived by modifying the official TPTP problem http://www.cs.miami.edu/~tptp/cgi-bin/SeeTPTP?Category=Problems&Domain=PUZ&File=PUZ047+1.p)

Notice that the conjecture is an existentially quantified formula, where the variable Z essentially stands for the solution. 
In such cases, Vampire can be instructed to automatically extract the value of the solution from any successful refutation.
This is called the Question Answering mode. To try this, you can run 

"./vampire_z3_rel_master_3993 ../satsmtar2018/PUZ047variant.p -qa answer_literal -av off"

(currently, question answering is incompatible with AVATAR.)

Notice the output line:

% SZS status Theorem for PUZ047variant
% SZS answers Tuple [[take_goat(go_alone(take_wolf(take_goat(take_cabbage(go_alone(take_goat(start)))))))]|_] for PUZ047variant

which encodes the solution.

For more details, check out Giles' paper: "Revisiting Question Answering in Vampire, VW 2017" (https://easychair.org/publications/open/5L6q).


Exercise 6 - Interpolation in Vampire
-------------------------------------

Interpolation is an advanced topic that will only be covered after this practical session. 

Here we provide a set of problems (see ./interpolation/*.p) that demonstrate the use of interpolation in Vampire.
The examples are written in a vampire-specific extension of TPTP that allows encoding interpolation-related information.

Let's have a look at Ex0_BasicConflict.p 

The construct

vampire(option,<option_name>,<value>).

is a way of setting Vampire options from an input file rather than, as usual, from the command line.
Here we use it to:

vampire(option,avatar,off).

turn off the avatar architecture, which is not yet fully compatible with interpolation,

vampire(option,show_interpolant,new_heur).

tell Vampire to generate and show interpolants when it proves the formula.

Interpolation in our settings is the following task. Given a `left' formula L, a `right' formula R, and possibly a set of background axioms A,
provided "L /\ R /\ A" is unsatisfiable, come up with an interpolant I, a formula satisfying
1) A /\ L => I,
2) A /\ I /\ R is unsatisfiable,
3) I does not contain symbols specific to L or R.

We need to tell Vampire which symbols are specific to L and R as in:

vampire(symbol,function,z,0,left).

which declares a new function "z" of arity 0, i.e. a constant, and marks it as belonging to the left formula.

Finally, 

vampire(left_formula).
  fof(fA,hypothesis,p(z)).
vampire(end_formula).

declares left formula itself and similarly

vampire(right_formula).
  fof(fB, hypothesis,![X]:~p(X)).
vampire(end_formula).

the right one. Note that there can be more than one fof(...) construct between the respective 

vampire(left_formula/right_fomrula). / vampire(end_formula).

"brackets".

In this example, Vampire finds the obvious trivial refutation and comes up with the interpolant

! [X0] : ~p(X0) => $false

which is minimised and simplified to

?[X0] : (p(X0))

Intuitively this existential formula summarises the left formula "p(z)" without mentioning the forbidden constant z.

---

We move our attention to example Ex0_BasicConflict_NoLocalProof.p. 

This is a slightly more complicated version of the previous example which demonstrates the limits of the interpolation method.
To produce interpolants, Vampire restricts its proof search to so called local proofs 
(proofs that don't ``mix'' special symbols such as the "z" above). 
To generate only local proofs certain inferences need to be blocked which leads to the loss of completeness. 

This is actually inherent, as it can be shown that sometimes, as in the case of this example, local proofs simply do not exits.

We see that Vampire terminates with the message:

% Refutation not found, inferences skipped due to colors

If we comment out the declaration:

vampire(symbol,function,c,0,left).

Vampire finds a proof, but the corresponding "interpolant"

(![X0] : (p(c,X0)))

still mentions the forbidden constant "c".

---

For more information on interpolation in Vampire, check out:
"Interpolation and Symbol Elimination. CADE 2009", 
"Playing in the grey area of proofs. POPL 2012",
"Splitting Proofs for Interpolation. CADE 2017", 
and "First-Order Interpolation and Interpolating Proof Systems. LPAR 2017".

---

Enjoy exploring the other examples in the directory "./interpolation".

