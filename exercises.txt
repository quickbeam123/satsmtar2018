Exercise 0 - obtaining Vampire:
-------------------------------

The source code of Vampire is available at 

https://github.com/vprover/vampire

for evaluation and research purposes (see LICENCE there for more details).

Full official vampire, that we will be using, requires the SMT solver Z3 as a library.

Z3 has been pre-installed on the provided VM. 

(In general, make sure there is sub-directory "include" of your "vampire" directory
and that it contains (a link to) the z3 library file "libz3.so" (unix) / "libz3.dylib" (mac).
In might be necessary to also make LD_LIBRARY_PATH (unix) / DYLD_LIBRARY_PATH (mac) contain the path
the this vampire's "include" dir.)

--- on the provided VM ---

- start the Terminal
- cd vampire
- git pull
- make vampire_z3_rel -j 3

should give us (as of 5 July 2018) vampire_z3_rel_master_3993


Exercise 1 - Limited Resource Strategy (LRS) and the time limit
---------------------------------------------------------------

Under certain conditions, LRS may behave in surprising ways. Because it actively discards
clauses which are estimated not to be useful before the allotted time is over, it may
prove things faster when given less time. Try running

./vampire_z3_rel_master_3993 -awr 5:1 -fsr off ../satsmtar2018/GRP140-1.p

Note that:
- LRS is on by default (otherwise "-sa lrs")
- "-awr 5:1 -fsr off" (age weight ration and forward subsumption resolution) are set to non-default to enable the desired effect

Now give Vampire less time (than the default 60s) with the option "-t 30", "-t 15", ... "-t 15d" (for 15 deciseconds = 1.5s)

What is the shortest time under which vampire finds a refutation?


Exercise 2 - A bit of group theory and finite model finding
-----------------------------------------------------------

Let's play a bit with the problem "grp_ord2.p" 

1) just let Vampire prove it and try understanding the proof.

./vampire_z3_rel_master_3993 ../satsmtar2018/grp_ord2.p 

2) Comment out the conjecture and run Vampire again as above.

What is it doing? Will it terminate?

Try adding "--show_active on" to see what clause is currently being activated.

Try adding "--show_new on" to see what clauses are getting generated.

ANSWER: It is saturating a satisfiable set of axioms. In theory, it might not terminate at all. 
Although there are cases of finite saturations. (Complete calculus + finite saturation -> problem shown satisfiable.)
We cannot be sure after finitely many steps. (By the way, here we are running with the default time limit of 60s.)

3) Without the conjecture, the problem is satisfiable, however saturation-based approaches are not very good at detecting it!
Let's try finite model building by adding "-sa fmb" 
(yes, the value "fmb" occurs under "saturation strategy", but as a technology, it has nothing to do with saturation).

What did we get? 

ANSWER: Finite model builder constructed a THE one element group (in which every element is of order 2).

4) Can add an axiom to make Vampire looking for larger models?

ANSWER: For instance, add 

fof(a,axiom,a!=e).

adding an extra constant "a" to the problem and stating it's not equal to the unit element "e".

5) Can you add axioms to force Vampire look for a group (in which every element is of order 2) of size exactly three?

ANSWER:

Add, for instance, 

fof(a,axiom,$distinct(a,b,c)).
fof(a,axiom,![X]:(X = a | X = b | X = c)).

Note that "$distinct(a,b,c)" is a shorthand for "a!=b & b!=c & a!=c".

Note that Vampire starts checking from size 3 as it noticed that 1 and 2 wouldn't work anyway.
Then after trying size 4 realises there cannot be any model and concludes "$false [finite model not found]"

The ability to show problems unsatisfiable using finite model building is a bit fancy. See our paper
"Finding Finite Models in Multi-sorted First-Order Logic. SAT 2016" if interested.

6) Actually, there is no group (in which every element is of order 2) which would have size 3. But it's pretty hard to prove by superposition / saturation.

The default strategy as in

"./vampire_z3_rel_master_3993 ../satsmtar2018/grp_ord2.p"

will have a hard time.

Adding "--mode casc" (instead of "-sa fmb") will employ Vampire's powerful strategy schedule and maybe find a suitable strategy to solve this hard(ish) problem. 

An extra challenge: try understanding the proof!


Exercise 3 - Challenge: Can you find the right strategy?
--------------------------------------------------------


Exercise 4 - Theories in Vampire, theory axioms, SMTLIB input
-------------------------------------------------------------





- sine ?

- large things?


Exercise 5 - Question answering mode 
------------------------------------



Exercise 6 - Clausify / TClausify
---------------------------------




Exercise 6 - Interpolation in Vampire
-------------------------------------

Interpolation is an advanced topic that will only be covered after this practical session. 

Here we provide a set of problems (see ./interpolation/*.p) that demonstrate the use of interpolation in Vampire.
The examples are written in a vampire-specific extension of TPTP that allows encoding interpolation-related information.

Let's have a look at Ex0_BasicConflict.p 

The construct

vampire(option,<option_name>,<value>).

is a way of setting Vampire options from an input file rather than, as usual, from the command line.
Here we use it to:

vampire(option,avatar,off).

turn off the avatar architecture, which is not yet fully compatible with interpolation,

vampire(option,show_interpolant,new_heur).

tell Vampire to generate and show interpolants when it proves the formula.

Interpolation in our settings is the following task. Given a `left' formula L, a `right' formula R, and possibly a set of background axioms A,
provided "L /\ R /\ A" is unsatisfiable, come up with an interpolant I, a formula satisfying
1) A /\ L => I,
2) A /\ I /\ R is unsatisfiable,
3) I does not contain symbols specific to L or R.

We need to tell Vampire which symbols are specific to L and R as in:

vampire(symbol,function,z,0,left).

which declares a new function "z" of arity 0, i.e. a constant, and marks it as belonging to the left formula.

Finally, 

vampire(left_formula).
  fof(fA,hypothesis,p(z)).
vampire(end_formula).

declares left formula itself and similarly

vampire(right_formula).
  fof(fB, hypothesis,![X]:~p(X)).
vampire(end_formula).

the right one. Note that there can be more than one fof(...) construct between the respective 

vampire(left_formula/right_fomrula). / vampire(end_formula).

"brackets".

In this example, Vampire finds the obvious trivial refutation and comes up with the interpolant

! [X0] : ~p(X0) => $false

which is minimised and simplified to

?[X0] : (p(X0))

Intuitively this existential formula summarises the left formula "p(z)" without mentioning the forbidden constant z.

---

We move our attention to example Ex0_BasicConflict_NoLocalProof.p. 

This is a slightly more complicated version of the previous example which demonstrates the limits of the interpolation method.
To produce interpolants, Vampire restricts its proof search to so called local proofs 
(proofs that don't ``mix'' special symbols such as the "z" above). 
To generate only local proofs certain inferences need to be blocked which leads to the loss of completeness. 

This is actually inherent, as it can be shown that sometimes, as in the case of this example, local proofs simply do not exits.

We see that Vampire terminates with the message:

% Refutation not found, inferences skipped due to colors

If we comment out the declaration:

vampire(symbol,function,c,0,left).

Vampire founds a proof, but the corresponding "interpolant"

(![X0] : (p(c,X0)))

still mentions the forbidden constant "c".

---

For more information on interpolation in Vampire, check out:
"Interpolation and Symbol Elimination. CADE 2009", 
"Playing in the grey area of proofs. POPL 2012",
"Splitting Proofs for Interpolation. CADE 2017", 
and "First-Order Interpolation and Interpolating Proof Systems. LPAR 2017".

---

Enjoy exploring the other examples in the directory "./interpolation".

